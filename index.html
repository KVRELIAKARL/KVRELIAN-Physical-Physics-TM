<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Physical Physics - By KVRELIA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #f0f0f5;
            touch-action: none;
        }

        /* Startup Screen */
        .startup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        .startup-logo {
            width: 300px;
            height: 300px;
            border-radius: 26px;
            overflow: hidden;
            animation: float 3s ease-in-out infinite;
        }

        .startup-logo video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        /* Progress Bar */
        .startup-progress-container {
            width: 280px;
            margin-top: 32px;
        }

        .startup-progress-text {
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
        }

        .startup-progress {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .startup-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #007AFF, #00A8FF);
            border-radius: 3px;
            transition: width 0.4s cubic-bezier(0.65, 0, 0.35, 1);
            position: relative;
        }

        .startup-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                            rgba(255,255,255,0.3) 0%, 
                            rgba(255,255,255,0.5) 50%, 
                            rgba(255,255,255,0.3) 100%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite;
            border-radius: 3px;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Setup Screen */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #f7f7fc;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.8s ease;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        .setup-container {
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .setup-header {
            padding: 20px;
            background: linear-gradient(to bottom, #f7f7fc, #ffffff);
            border-bottom: 1px solid #e5e5ea;
            text-align: center;
            flex-shrink: 0;
        }

        .setup-title {
            font-size: 22px;
            font-weight: 600;
            color: #1c1c1e;
            margin-bottom: 8px;
        }

        .setup-subtitle {
            font-size: 14px;
            color: #636366;
        }

        .setup-content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
            -webkit-overflow-scrolling: touch;
        }

        .setup-section {
            margin-bottom: 24px;
        }

        .setup-section-title {
            font-size: 16px;
            font-weight: 500;
            color: #1c1c1e;
            margin-bottom: 12px;
        }

        .language-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            padding: 8px;
        }

        .language-option {
            padding: 12px;
            border: 1px solid #e5e5ea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            user-select: none;
        }

        .language-option:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .language-option.selected {
            border-color: #007AFF;
            background-color: #e6f2ff;
        }

        .language-flag {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-bottom: 8px;
            object-fit: cover;
        }

        .language-name {
            font-size: 14px;
            font-weight: 500;
            color: #1c1c1e;
        }

        .tutorial-steps {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .tutorial-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .tutorial-icon {
            width: 24px;
            height: 24px;
            background: #007AFF;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            flex-shrink: 0;
        }

        .tutorial-text {
            font-size: 14px;
            color: #636366;
            line-height: 1.5;
        }

        .setup-footer {
            padding: 16px 20px;
            background: #f7f7fc;
            border-top: 1px solid #e5e5ea;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .setup-button {
            padding: 8px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .setup-button.primary {
            background: #007AFF;
            color: white;
            border: none;
        }

        .setup-button.primary:hover {
            background: #0066CC;
        }

        .setup-button.secondary {
            background: transparent;
            border: 1px solid #e5e5ea;
            color: #636366;
        }

        .setup-button.secondary:hover {
            background: #f5f5f7;
        }

        /* Logo Replay Screen */
        .logo-replay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 998;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .logo-replay .startup-logo {
            animation: none;
            width: 400px;
            height: 400px;
        }

        /* Menu Bar */
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(30px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
            -webkit-backdrop-filter: blur(30px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .menu-title {
            font-size: 16px;
            font-weight: 500;
            color: #1a1a1a;
        }

        /* Dock */
        .dock {
            position: fixed;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(40px);
            border-radius: 16px;
            padding: 12px;
            display: none;
            gap: 16px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            cursor: grab;
            user-select: none;
            opacity: 0;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            -webkit-backdrop-filter: blur(40px);
            touch-action: none;
            width: auto;
            max-width: 90%;
            margin: 0 auto;
            white-space: nowrap;
            overflow-x: auto;
        }

        .dock.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .dock-item {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.7);
            transition: all 0.2s ease;
            font-size: 24px;
            user-select: none;
            flex-shrink: 0;
        }

        .dock-item:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.9);
        }

        .dock-item.active {
            background: rgba(0, 122, 255, 0.2);
        }

        /* Canvas */
        #canvas {
            position: fixed;
            top: 44px;
            left: 0;
            width: 100%;
            height: calc(100% - 44px);
            z-index: 0;
            touch-action: none;
        }

        /* macOS Style Tooltip */
        .object-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            transform: translateY(10px);
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            white-space: nowrap;
        }

        .object-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .object-tooltip::after {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid rgba(0, 0, 0, 0.8);
        }

        /* Edit Controls */
        .edit-controls {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            display: none;
            gap: 10px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            -webkit-backdrop-filter: blur(20px);
            touch-action: none;
        }

        .edit-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 122, 255, 0.1);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 18px;
            user-select: none;
        }

        .edit-btn:hover {
            background: rgba(0, 122, 255, 0.2);
        }

        .edit-btn.active {
            background: rgba(0, 122, 255, 0.3);
        }

        .size-slider {
            width: 120px;
            display: flex;
            align-items: center;
        }

        .size-slider input {
            width: 100%;
        }

        /* Puzzle Mode UI */
        .puzzle-mode {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            gap: 10px;
            -webkit-backdrop-filter: blur(20px);
        }

        .puzzle-header {
            font-size: 16px;
            font-weight: 600;
            color: #1c1c1e;
            margin-bottom: 8px;
        }

        .puzzle-objective {
            font-size: 14px;
            color: #636366;
            margin-bottom: 12px;
        }

        .puzzle-controls {
            display: flex;
            gap: 8px;
        }

        .puzzle-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            user-select: none;
        }

        .puzzle-btn.primary {
            background: #007AFF;
            color: white;
        }

        .puzzle-btn.primary:hover {
            background: #0066CC;
        }

        .puzzle-btn.secondary {
            background: #e5e5ea;
            color: #1c1c1e;
        }

        .puzzle-btn.secondary:hover {
            background: #d1d1d6;
        }

        .target-zone {
            position: absolute;
            border: 2px dashed #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            z-index: 10;
            pointer-events: none;
        }

        .puzzle-complete {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            color: white;
            font-size: 24px;
            text-align: center;
        }

        .puzzle-complete h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        .puzzle-complete p {
            margin-bottom: 30px;
            max-width: 80%;
        }

        .puzzle-complete-btn {
            padding: 12px 24px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .puzzle-complete-btn:hover {
            background: #0066CC;
        }

        /* Menu Button */
        .menu-button {
            position: fixed;
            top: 60px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            -webkit-backdrop-filter: blur(20px);
            user-select: none;
        }

        .menu-button:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        /* Puzzle Selection Menu */
        .puzzle-menu {
            position: fixed;
            top: 110px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            gap: 8px;
            width: 200px;
            max-height: 70vh;
            overflow-y: auto;
            -webkit-backdrop-filter: blur(20px);
            -webkit-overflow-scrolling: touch;
        }

        .puzzle-menu-item {
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }

        .puzzle-menu-item:hover {
            background: rgba(0, 122, 255, 0.1);
        }

        .puzzle-menu-item.active {
            background: rgba(0, 122, 255, 0.2);
            font-weight: 500;
        }

        .puzzle-difficulty {
            font-size: 12px;
            color: #636366;
            margin-top: 4px;
        }

        /* Pause overlay */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            color: white;
            font-size: 24px;
        }

        .pause-overlay h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        .pause-btn {
            padding: 12px 24px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-top: 20px;
        }

        .pause-btn:hover {
            background: #0066CC;
        }

        /* Notification System */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 6px;
            background: #007AFF;
            color: white;
            z-index: 2000;
            transition: opacity 0.3s;
            max-width: 90%;
            text-align: center;
        }

        .notification.error {
            background: #FF3B30;
        }

        .notification.fade-out {
            opacity: 0;
        }

        /* Save/Load Controls */
        .save-load-controls {
            position: fixed;
            top: 60px;
            right: 20px;
            display: none;
            gap: 10px;
            z-index: 1000;
        }

        .save-btn, .load-btn {
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(0, 122, 255, 0.1);
            border: none;
            color: #007AFF;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .save-btn:hover, .load-btn:hover {
            background: rgba(0, 122, 255, 0.2);
        }

        /* Particle Effects */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            opacity: 0.8;
            transform: translate(-50%, -50%);
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .dock {
                width: 90%;
                max-width: none;
                padding: 8px;
                gap: 8px;
                bottom: 10px;
            }
            
            .dock-item {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }
            
            .menu-button {
                top: 10px;
                left: 10px;
                width: 36px;
                height: 36px;
            }
            
            .puzzle-mode {
                top: 60px;
                right: 10px;
                left: 10px;
                width: calc(100% - 20px);
            }
            
            .edit-controls {
                bottom: 80px;
                width: 90%;
                padding: 8px;
            }
            
            .save-load-controls {
                top: 10px;
                right: 10px;
            }
            
            .puzzle-menu {
                top: 56px;
                left: 10px;
                width: calc(100% - 20px);
                max-height: 60vh;
            }
            
            .startup-logo {
                width: 200px;
                height: 200px;
            }
            
            .logo-replay .startup-logo {
                width: 300px;
                height: 300px;
            }
        }

        /* Landscape mode adjustments */
        @media (orientation: landscape) {
            .dock {
                bottom: 10px;
                padding: 8px;
                gap: 8px;
            }
            
            .dock-item {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }
            
            .menu-button {
                top: 10px;
                left: 10px;
            }
            
            .puzzle-mode {
                top: 10px;
                right: 10px;
            }
            
            .edit-controls {
                bottom: 70px;
            }
            
            .save-load-controls {
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="startup-screen" id="startupScreen">
        <div class="startup-logo">
            <video autoplay muted loop playsinline id="startupVideo">
                <source src="https://i.imgur.com/8933jDg.mp4" type="video/mp4">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDA3QUZGIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPlBoeXNpY2FsIFBoeXNpY3M8L3RleHQ+PC9zdmc+" alt="Physical Physics Logo">
                Your browser does not support the video tag.
            </video>
        </div>
        <div class="startup-progress-container">
            <div class="startup-progress-text" id="progressText">Loading Physical Physics</div>
            <div class="startup-progress">
                <div class="startup-progress-bar" id="startupProgress"></div>
            </div>
        </div>
    </div>

    <div class="setup-screen" id="setupScreen">
        <div class="setup-container">
            <div class="setup-header">
                <div class="setup-title" id="setupTitle">Welcome to Physical Physics</div>
                <div class="setup-subtitle" id="setupSubtitle">Let's get started with a few quick settings</div>
            </div>
            <div class="setup-content">
                <div class="setup-section">
                    <div class="setup-section-title" id="languageTitle">Select Language</div>
                    <div class="language-options">
                        <div class="language-option selected" data-lang="en">
                            <img src="https://flagcdn.com/w20/gb.png" class="language-flag">
                            <div class="language-name">English</div>
                        </div>
                        <div class="language-option" data-lang="es">
                            <img src="https://flagcdn.com/w20/es.png" class="language-flag">
                            <div class="language-name">Espa√±ol</div>
                        </div>
                        <div class="language-option" data-lang="fr">
                            <img src="https://flagcdn.com/w20/fr.png" class="language-flag">
                            <div class="language-name">Fran√ßais</div>
                        </div>
                        <div class="language-option" data-lang="de">
                            <img src="https://flagcdn.com/w20/de.png" class="language-flag">
                            <div class="language-name">Deutsch</div>
                        </div>
                        <div class="language-option" data-lang="ja">
                            <img src="https://flagcdn.com/w20/jp.png" class="language-flag">
                            <div class="language-name">Êó•Êú¨Ë™û</div>
                        </div>
                        <div class="language-option" data-lang="ko">
                            <img src="https://flagcdn.com/w20/kr.png" class="language-flag">
                            <div class="language-name">ÌïúÍµ≠Ïñ¥</div>
                        </div>
                        <div class="language-option" data-lang="tl">
                            <img src="https://flagcdn.com/w20/ph.png" class="language-flag">
                            <div class="language-name">Tagalog</div>
                        </div>
                    </div>
                </div>
                <div class="setup-section">
                    <div class="setup-section-title" id="tutorialTitle">Quick Tutorial</div>
                    <div class="tutorial-steps">
                        <div class="tutorial-step">
                            <div class="tutorial-icon">1</div>
                            <div class="tutorial-text" id="tutorialStep1">Tap on the dock icons to select different shapes to create</div>
                        </div>
                        <div class="tutorial-step">
                            <div class="tutorial-icon">2</div>
                            <div class="tutorial-text" id="tutorialStep2">Tap anywhere on the canvas to place your selected shape</div>
                        </div>
                        <div class="tutorial-step">
                            <div class="tutorial-icon">3</div>
                            <div class="tutorial-text" id="tutorialStep3">Long-press on objects to enter edit mode</div>
                        </div>
                        <div class="tutorial-step">
                            <div class="tutorial-icon">4</div>
                            <div class="tutorial-text" id="tutorialStep4">Select the trash icon to delete objects by tapping on them</div>
                        </div>
                        <div class="tutorial-step">
                            <div class="tutorial-icon">5</div>
                            <div class="tutorial-text" id="tutorialStep5">Try Puzzle Mode from the menu button for physics challenges</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="setup-footer">
                <button class="setup-button secondary" id="skipButton">Skip</button>
                <button class="setup-button primary" id="continueButton">Continue</button>
            </div>
        </div>
    </div>

    <div class="logo-replay" id="logoReplay">
        <div class="startup-logo">
            <video autoplay muted playsinline id="replayVideo">
                <source src="https://i.imgur.com/zSrGcf7.mp4" type="video/mp4">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDA3QUZGIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIzNiIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPlBoeXNpY2FsIFBoeXNpY3M8L3RleHQ+PC9zdmc+" alt="Physical Physics Logo">
                Your browser does not support the video tag.
            </video>
        </div>
    </div>

    <div class="menu-bar">
        <div class="menu-title" id="menuTitle">Physical Physics - By KVRELIA</div>
    </div>

    <div class="save-load-controls" id="saveLoadControls">
        <button class="save-btn" id="saveBtn">Save</button>
        <button class="load-btn" id="loadBtn">Load</button>
    </div>

    <div class="menu-button" id="menuButton">‚â°</div>
    <div class="puzzle-menu" id="puzzleMenu">
        <div class="puzzle-header">Puzzle Challenges</div>
        <!-- Puzzle items will be added dynamically -->
    </div>

    <div class="dock" id="dock">
        <div class="dock-item active" data-mode="box">üü¶</div>
        <div class="dock-item" data-mode="circle">üî¥</div>
        <div class="dock-item" data-mode="triangle">üî∫</div>
        <div class="dock-item" data-mode="hexagon">‚¨°</div>
        <div class="dock-item" data-mode="static">üü©</div>
        <div class="dock-item" data-mode="delete">üóëÔ∏è</div>
        <div class="dock-item" data-mode="pause">‚è∏Ô∏è</div>
    </div>

    <canvas id="canvas"></canvas>
    <div id="tooltip" class="object-tooltip"></div>

    <div class="edit-controls" id="editControls">
        <button class="edit-btn" id="moveBtn">‚úã</button>
        <button class="edit-btn" id="resizeBtn">‚ÜîÔ∏è</button>
        <div class="size-slider">
            <input type="range" id="sizeSlider" min="10" max="100" value="40">
        </div>
        <button class="edit-btn" id="confirmEditBtn">‚úì</button>
        <button class="edit-btn" id="cancelEditBtn">‚úï</button>
    </div>

    <!-- Puzzle Mode UI -->
    <div class="puzzle-mode" id="puzzleMode">
        <div class="puzzle-header" id="puzzleTitle">Puzzle Challenge</div>
        <div class="puzzle-objective" id="puzzleObjective">Place the ball in the target zone</div>
        <div class="puzzle-controls">
            <button class="puzzle-btn secondary" id="resetPuzzleBtn">Reset</button>
            <button class="puzzle-btn primary" id="exitPuzzleBtn">Exit Puzzle</button>
            <button class="puzzle-btn" id="pausePuzzleBtn">Pause</button>
        </div>
    </div>

    <!-- Puzzle Complete Screen -->
    <div class="puzzle-complete" id="puzzleComplete">
        <h2>Puzzle Complete!</h2>
        <p id="completeMessage">You successfully placed the ball in the target zone!</p>
        <button class="puzzle-complete-btn" id="nextPuzzleBtn">Next Puzzle</button>
    </div>

    <!-- Pause Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <h2>Paused</h2>
        <p>Edit your objects while paused</p>
        <button class="pause-btn" id="resumeBtn">Resume</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script>
        // Modules aliases
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Query = Matter.Query,
              Constraint = Matter.Constraint;

        let engine, render, runner;
        let currentMode = 'box';
        const bodies = [];
        let isProcessingClick = false;
        let selectedLanguage = 'en';

        // Edit mode variables
        let editMode = false;
        let moveMode = false;
        let resizeMode = false;
        let selectedBody = null;
        let originalBodyState = null;

        // Puzzle mode variables
        let puzzleMode = false;
        let currentPuzzle = null;
        let targetZone = null;
        let targetBody = null;
        let puzzleBodies = [];
        let puzzleCheckInterval = null;

        // Pause state
        let isPaused = false;
        let prePauseRunner = null;

        // Mobile detection
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Audio Manager
        const audio = {
            click: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3'),
            thud: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-boxing-punch-2058.mp3'),
            success: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3'),
            play(name, volume = 0.3) {
                const sound = this[name].cloneNode(); // Avoid overlapping sounds
                sound.volume = volume;
                sound.play().catch(e => console.log("Audio blocked:", e));
            }
        };

        // Particle System
        function spawnParticles(x, y, color = '#FFD700', count = 5) {
            if (isMobile()) count = Math.min(3, count); // Reduce particles on mobile
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const size = Math.random() * 8 + 2;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.background = color;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                document.body.appendChild(particle);
                
                // Animate
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const lifetime = Math.random() * 1000 + 500;
                
                let startTime = Date.now();
                const updateParticle = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / lifetime;
                    
                    if (progress >= 1) {
                        particle.remove();
                        return;
                    }
                    
                    const distance = speed * elapsed * 0.1;
                    particle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                    particle.style.opacity = 1 - progress;
                    requestAnimationFrame(updateParticle);
                };
                
                requestAnimationFrame(updateParticle);
            }
        }

        // Translation dictionary
        const translations = {
            en: {
                welcome: "Welcome to Physical Physics",
                subtitle: "Let's get started with a few quick settings",
                language: "Select Language",
                tutorial: "Quick Tutorial",
                step1: "Tap on the dock icons to select different shapes to create",
                step2: "Tap anywhere on the canvas to place your selected shape",
                step3: "Long-press on objects to enter edit mode",
                step4: "Select the trash icon to delete objects by tapping on them",
                step5: "Try Puzzle Mode from the menu button for physics challenges",
                skip: "Skip",
                continue: "Continue",
                loading: "Loading Physical Physics",
                ready: "Ready!",
                menuTitle: "Physical Physics - By KVRELIA",
                box: "Box",
                circle: "Circle",
                triangle: "Triangle",
                hexagon: "Hexagon",
                static: "Static Block",
                puzzleTitle: "Puzzle Challenge",
                puzzleObjective: "Place the ball in the target zone",
                resetPuzzle: "Reset",
                exitPuzzle: "Exit Puzzle",
                puzzleComplete: "Puzzle Complete!",
                nextPuzzle: "Next Puzzle",
                puzzleMenu: "Puzzle Challenges",
                easy: "Easy",
                medium: "Medium",
                hard: "Hard",
                paused: "Paused",
                resume: "Resume",
                pause: "Pause",
                save: "Save",
                load: "Load",
                sceneSaved: "Scene saved successfully!",
                sceneLoaded: "Scene loaded successfully!",
                loadError: "Error loading scene"
            },
            es: {
                welcome: "Bienvenido a Physical Physics",
                subtitle: "Comencemos con algunas configuraciones r√°pidas",
                language: "Selecciona el idioma",
                tutorial: "Tutorial r√°pido",
                step1: "Toca los iconos del dock para seleccionar diferentes formas",
                step2: "Toca en cualquier lugar del lienzo para colocar tu forma seleccionada",
                step3: "Mant√©n presionado objetos para entrar en modo de edici√≥n",
                step4: "Selecciona el icono de basura para eliminar objetos",
                step5: "Prueba el Modo Puzzle desde el bot√≥n de men√∫ para desaf√≠os de f√≠sica",
                skip: "Saltar",
                continue: "Continuar",
                loading: "Cargando Physical Physics",
                ready: "¬°Listo!",
                menuTitle: "Physical Physics - Por KVRELIA",
                box: "Caja",
                circle: "C√≠rculo",
                triangle: "Tri√°ngulo",
                hexagon: "Hex√°gono",
                static: "Bloque est√°tico",
                puzzleTitle: "Desaf√≠o de Puzzle",
                puzzleObjective: "Coloca la pelota en la zona objetivo",
                resetPuzzle: "Reiniciar",
                exitPuzzle: "Salir del Puzzle",
                puzzleComplete: "¬°Puzzle Completado!",
                nextPuzzle: "Siguiente Puzzle",
                puzzleMenu: "Desaf√≠os de Puzzle",
                easy: "F√°cil",
                medium: "Medio",
                hard: "Dif√≠cil",
                paused: "En pausa",
                resume: "Continuar",
                pause: "Pausa",
                save: "Guardar",
                load: "Cargar",
                sceneSaved: "Escena guardada con √©xito!",
                sceneLoaded: "Escena cargada con √©xito!",
                loadError: "Error al cargar escena"
            },
            fr: {
                welcome: "Bienvenue dans Physical Physics",
                subtitle: "Commen√ßons avec quelques r√©glages rapides",
                language: "S√©lectionnez la langue",
                tutorial: "Tutoriel rapide",
                step1: "Appuyez sur les ic√¥nes du dock pour s√©lectionner diff√©rentes formes",
                step2: "Appuyez n'importe o√π sur le canevas pour placer votre forme s√©lectionn√©e",
                step3: "Appuyez longuement sur les objets pour entrer en mode √©dition",
                step4: "Selecciona el icono poubelle pour supprimer des objets",
                step5: "Essayez le Mode Puzzle depuis le bouton de menu pour des d√©fis physiques",
                skip: "Passer",
                continue: "Continuer",
                loading: "Chargement de Physical Physics",
                ready: "Pr√™t!",
                menuTitle: "Physical Physics - Par KVRELIA",
                box: "Bo√Æte",
                circle: "Cercle",
                triangle: "Triangle",
                hexagon: "Hexagone",
                static: "Bloc statique",
                puzzleTitle: "D√©fi Puzzle",
                puzzleObjective: "Placez la balle dans la zone cible",
                resetPuzzle: "R√©initialiser",
                exitPuzzle: "Quitter le Puzzle",
                puzzleComplete: "Puzzle Termin√©!",
                nextPuzzle: "Puzzle Suivant",
                puzzleMenu: "D√©fis Puzzle",
                easy: "Facile",
                medium: "Moyen",
                hard: "Difficile",
                paused: "En pause",
                resume: "Reprendre",
                pause: "Pause",
                save: "Sauvegarder",
                load: "Charger",
                sceneSaved: "Sc√®ne sauvegard√©e avec succ√®s!",
                sceneLoaded: "Sc√®ne charg√©e avec succ√®s!",
                loadError: "Erreur lors du chargement de la sc√®ne"
            },
            de: {
                welcome: "Willkommen bei Physical Physics",
                subtitle: "Beginnen wir mit einigen schnellen Einstellungen",
                language: "Sprache ausw√§hlen",
                tutorial: "Schnellanleitung",
                step1: "Tippen Sie auf die Dock-Symbole, um verschiedene Formen auszuw√§hlen",
                step2: "Tippen Sie auf die Leinwand, um Ihre ausgew√§hlte Form zu platzieren",
                step3: "Halten Sie Objekte gedr√ºckt, um den Bearbeitungsmodus zu aktivieren",
                step4: "W√§hlen Sie das M√ºlleimer-Symbol aus, um Objekte zu l√∂schen",
                step5: "Probieren Sie den Puzzle-Modus √ºber die Men√ºtaste f√ºr physikalische Herausforderungen",
                skip: "√úberspringen",
                continue: "Weiter",
                loading: "Lade Physical Physics",
                ready: "Fertig!",
                menuTitle: "Physical Physics - Von KVRELIA",
                box: "Kasten",
                circle: "Kreis",
                triangle: "Dreieck",
                hexagon: "Sechseck",
                static: "Statischer Block",
                puzzleTitle: "Puzzle-Herausforderung",
                puzzleObjective: "Platzieren Sie den Ball in der Zielzone",
                resetPuzzle: "Zur√ºcksetzen",
                exitPuzzle: "Puzzle verlassen",
                puzzleComplete: "Puzzle abgeschlossen!",
                nextPuzzle: "N√§chstes Puzzle",
                puzzleMenu: "Puzzle-Herausforderungen",
                easy: "Einfach",
                medium: "Mittel",
                hard: "Schwer",
                paused: "Pausiert",
                resume: "Fortsetzen",
                pause: "Pause",
                save: "Speichern",
                load: "Laden",
                sceneSaved: "Szene erfolgreich gespeichert!",
                sceneLoaded: "Szene erfolgreich geladen!",
                loadError: "Fehler beim Laden der Szene"
            },
            ja: {
                welcome: "Physical Physics„Å∏„Çà„ÅÜ„Åì„Åù",
                subtitle: "Á∞°Âçò„Å™Ë®≠ÂÆö„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ",
                language: "Ë®ÄË™û„ÇíÈÅ∏Êäû",
                tutorial: "„ÇØ„Ç§„ÉÉ„ÇØ„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´",
                step1: "„Éâ„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥„Çí„Çø„ÉÉ„Éó„Åó„Å¶‰ΩúÊàê„Åô„ÇãÂΩ¢Áä∂„ÇíÈÅ∏Êäû",
                step2: "„Ç≠„É£„É≥„Éê„Çπ„Çí„Çø„ÉÉ„Éó„Åó„Å¶ÈÅ∏Êäû„Åó„ÅüÂΩ¢Áä∂„ÇíÈÖçÁΩÆ",
                step3: "„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈï∑Êäº„Åó„Åó„Å¶Á∑®ÈõÜ„É¢„Éº„Éâ„Å´ÂÖ•„Çã",
                step4: "„Ç¥„ÉüÁÆ±„Ç¢„Ç§„Ç≥„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§",
                step5: "„É°„Éã„É•„Éº„Éú„Çø„É≥„Åã„Çâ„Éë„Ç∫„É´„É¢„Éº„Éâ„ÇíË©¶„Åó„Å¶Áâ©ÁêÜÁöÑ„Å™ÊåëÊà¶„Çí",
                skip: "„Çπ„Ç≠„ÉÉ„Éó",
                continue: "Á∂ö„Åë„Çã",
                loading: "Physical Physics„ÇíË™≠„ÅøËæº„Åø‰∏≠",
                ready: "Ê∫ñÂÇôÂÆå‰∫Ü!",
                menuTitle: "Physical Physics - KVRELIA‰Ωú",
                box: "„Éú„ÉÉ„ÇØ„Çπ",
                circle: "ÂÜÜ",
                triangle: "‰∏âËßíÂΩ¢",
                hexagon: "ÂÖ≠ËßíÂΩ¢",
                static: "Âõ∫ÂÆö„Éñ„É≠„ÉÉ„ÇØ",
                puzzleTitle: "„Éë„Ç∫„É´„ÉÅ„É£„É¨„É≥„Ç∏",
                puzzleObjective: "„Éú„Éº„É´„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Çæ„Éº„É≥„Å´ÈÖçÁΩÆ",
                resetPuzzle: "„É™„Çª„ÉÉ„Éà",
                exitPuzzle: "„Éë„Ç∫„É´„ÇíÁµÇ‰∫Ü",
                puzzleComplete: "„Éë„Ç∫„É´ÂÆå‰∫Ü!",
                nextPuzzle: "Ê¨°„ÅÆ„Éë„Ç∫„É´",
                puzzleMenu: "„Éë„Ç∫„É´„ÉÅ„É£„É¨„É≥„Ç∏",
                easy: "Á∞°Âçò",
                medium: "‰∏≠Á¥ö",
                hard: "Èõ£„Åó„ÅÑ",
                paused: "‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠",
                resume: "ÂÜçÈñã",
                pause: "‰∏ÄÊôÇÂÅúÊ≠¢",
                save: "‰øùÂ≠ò",
                load: "Ë™≠„ÅøËæº„Åø",
                sceneSaved: "„Ç∑„Éº„É≥„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü!",
                sceneLoaded: "„Ç∑„Éº„É≥„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü!",
                loadError: "„Ç∑„Éº„É≥„ÅÆË™≠„ÅøËæº„Åø„Ç®„É©„Éº"
            },
            ko: {
                welcome: "Physical PhysicsÏóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§",
                subtitle: "Îπ†Î•∏ ÏÑ§Ï†ïÏúºÎ°ú ÏãúÏûëÌï¥ Î≥¥ÏÑ∏Ïöî",
                language: "Ïñ∏Ïñ¥ ÏÑ†ÌÉù",
                tutorial: "Îπ†Î•∏ ÏÇ¨Ïö©Î≤ï",
                step1: "ÎèÖ ÏïÑÏù¥ÏΩòÏùÑ ÌÉ≠ÌïòÏó¨ ÎßåÎì§ Î™®ÏñëÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî",
                step2: "Ï∫îÎ≤ÑÏä§ ÏïÑÎ¨¥ Í≥≥Ïù¥ÎÇò ÌÉ≠ÌïòÏó¨ ÏÑ†ÌÉùÌïú Î™®ÏñëÏùÑ Î∞∞ÏπòÌïòÏÑ∏Ïöî",
                step3: "Í∞ùÏ≤¥Î•º Í∏∏Í≤å ÎàåÎü¨ Ìé∏Ïßë Î™®ÎìúÎ°ú Îì§Ïñ¥Í∞ÄÏÑ∏Ïöî",
                step4: "Ìú¥ÏßÄÌÜµ ÏïÑÏù¥ÏΩòÏùÑ ÏÑ†ÌÉùÌïòÏó¨ Í∞ùÏ≤¥Î•º ÏÇ≠Ï†úÌïòÏÑ∏Ïöî",
                step5: "Î©îÎâ¥ Î≤ÑÌäºÏóêÏÑú ÌçºÏ¶ê Î™®ÎìúÎ•º ÏãúÎèÑÌï¥ Î¨ºÎ¶¨Ï†Å ÎèÑÏ†ÑÏùÑ Ìï¥Î≥¥ÏÑ∏Ïöî",
                skip: "Í±¥ÎÑàÎõ∞Í∏∞",
                continue: "Í≥ÑÏÜç",
                loading: "Physical Physics Î°úÎìú Ï§ë",
                ready: "Ï§ÄÎπÑ ÏôÑÎ£å!",
                menuTitle: "Physical Physics - KVRELIA Ï†úÏûë",
                box: "ÏÉÅÏûê",
                circle: "Ïõê",
                triangle: "ÏÇºÍ∞ÅÌòï",
                hexagon: "Ïú°Í∞ÅÌòï",
                static: "Í≥†Ï†ï Î∏îÎ°ù",
                puzzleTitle: "ÌçºÏ¶ê ÎèÑÏ†Ñ",
                puzzleObjective: "Í≥µÏùÑ Î™©Ìëú ÏòÅÏó≠Ïóê Î∞∞ÏπòÌïòÏÑ∏Ïöî",
                resetPuzzle: "Ïû¨ÏÑ§Ï†ï",
                exitPuzzle: "ÌçºÏ¶ê Ï¢ÖÎ£å",
                puzzleComplete: "ÌçºÏ¶ê ÏôÑÎ£å!",
                nextPuzzle: "Îã§Ïùå ÌçºÏ¶ê",
                puzzleMenu: "ÌçºÏ¶ê ÎèÑÏ†Ñ",
                easy: "Ïâ¨ÏõÄ",
                medium: "Ï§ëÍ∞Ñ",
                hard: "Ïñ¥Î†§ÏõÄ",
                paused: "ÏùºÏãú Ï†ïÏßÄÎê®",
                resume: "Í≥ÑÏÜçÌïòÍ∏∞",
                pause: "ÏùºÏãú Ï†ïÏßÄ",
                save: "Ï†ÄÏû•",
                load: "Î∂àÎü¨Ïò§Í∏∞",
                sceneSaved: "Ïî¨ Ï†ÄÏû• ÏÑ±Í≥µ!",
                sceneLoaded: "Ïî¨ Î∂àÎü¨Ïò§Í∏∞ ÏÑ±Í≥µ!",
                loadError: "Ïî¨ Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò"
            },
            tl: {
                welcome: "Maligayang pagdating sa Physical Physics",
                subtitle: "Magsimula tayo sa ilang mabilis na setting",
                language: "Pumili ng wika",
                tutorial: "Mabilis na gabay",
                step1: "I-tap ang mga icon sa dock para pumili ng iba't ibang hugis",
                step2: "I-tap kahit saan sa canvas para ilagay ang napiling hugis",
                step3: "Pindutin ng matagas ang mga bagay para mag-edit",
                step4: "Piliin ang trash icon para burahin ang mga bagay",
                step5: "Subukan ang Puzzle Mode mula sa menu button para sa physics challenges",
                skip: "Laktawan",
                continue: "Magpatuloy",
                loading: "Naglo-load ng Physical Physics",
                ready: "Handa na!",
                menuTitle: "Physical Physics - Ni KVRELIA",
                box: "Kahon",
                circle: "Bilog",
                triangle: "Tatsulok",
                hexagon: "Heksagono",
                static: "Hindi gumagalaw na bloke",
                puzzleTitle: "Puzzle Challenge",
                puzzleObjective: "Ilagay ang bola sa target zone",
                resetPuzzle: "I-reset",
                exitPuzzle: "Umalis sa Puzzle",
                puzzleComplete: "Puzzle Kumpleto!",
                nextPuzzle: "Susunod na Puzzle",
                puzzleMenu: "Mga Puzzle Challenge",
                easy: "Madali",
                medium: "Katamtaman",
                hard: "Mahirap",
                paused: "Naka-pause",
                resume: "Ipagpatuloy",
                pause: "I-pause",
                save: "I-save",
                load: "I-load",
                sceneSaved: "Tagumpay na na-save ang scene!",
                sceneLoaded: "Tagumpay na na-load ang scene!",
                loadError: "Error sa pag-load ng scene"
            }
        };

        // Puzzle definitions
        const puzzles = [
            {
                id: 'balance',
                title: "Balance Challenge",
                difficulty: "easy",
                objective: "Balance the triangle on top of the box",
                setup: () => {
                    // Clear existing bodies
                    Composite.clear(engine.world, false);
                    bodies.length = 0;
                    
                    // Create ground
                    const ground = Bodies.rectangle(
                        render.options.width / 2,
                        render.options.height - 20,
                        render.options.width,
                        40,
                        { isStatic: true, render: { fillStyle: '#34C759' } }
                    );
                    
                    // Create base box
                    const base = Bodies.rectangle(
                        render.options.width / 2,
                        render.options.height - 100,
                        120,
                        40,
                        { isStatic: false, render: { fillStyle: '#007AFF' } }
                    );
                    
                    // Create triangle to balance
                    const triangleVertices = [
                        { x: 0, y: -40 },
                        { x: 40, y: 40 },
                        { x: -40, y: 40 }
                    ];
                    const triangle = Bodies.fromVertices(
                        render.options.width / 2,
                        render.options.height - 200,
                        [triangleVertices],
                        { isStatic: false, render: { fillStyle: '#FFD700' } }
                    );
                    
                    Composite.add(engine.world, [ground, base, triangle]);
                    
                    // Set puzzle bodies
                    return {
                        bodies: [ground, base, triangle],
                        targetBody: triangle,
                        targetZone: ground,
                        paused: false,
                        allowCreation: false
                    };
                }
            },
            {
                id: 'target',
                title: "Target Practice",
                difficulty: "medium",
                objective: "Get the ball into the target zone",
                setup: () => {
                    // Clear existing bodies
                    Composite.clear(engine.world, false);
                    bodies.length = 0;
                    
                    // Create ground
                    const ground = Bodies.rectangle(
                        render.options.width / 2,
                        render.options.height - 20,
                        render.options.width,
                        40,
                        { isStatic: true, render: { fillStyle: '#34C759' } }
                    );
                    
                    // Create walls
                    const leftWall = Bodies.rectangle(
                        20,
                        render.options.height / 2,
                        40,
                        render.options.height,
                        { isStatic: true, render: { fillStyle: '#8E8E93' } }
                    );
                    
                    const rightWall = Bodies.rectangle(
                        render.options.width - 20,
                        render.options.height / 2,
                        40,
                        render.options.height,
                        { isStatic: true, render: { fillStyle: '#8E8E93' } }
                    );
                    
                    // Create target zone
                    const targetZone = Bodies.rectangle(
                        render.options.width - 100,
                        100,
                        80,
                        80,
                        { 
                            isStatic: true, 
                            isSensor: true,
                            render: { 
                                fillStyle: 'rgba(0, 122, 255, 0.2)',
                                strokeStyle: '#007AFF',
                                lineWidth: 2
                            } 
                        }
                    );
                    
                    // Create ball
                    const ball = Bodies.circle(
                        100,
                        100,
                        20,
                        { 
                            isStatic: false, 
                            restitution: 0.8,
                            render: { fillStyle: '#FF3B30' } 
                        }
                    );
                    
                    Composite.add(engine.world, [ground, leftWall, rightWall, targetZone, ball]);
                    
                    // Create visual target zone
                    createTargetZone(
                        targetZone.bounds.min.x,
                        targetZone.bounds.min.y,
                        targetZone.bounds.max.x - targetZone.bounds.min.x,
                        targetZone.bounds.max.y - targetZone.bounds.min.y
                    );
                    
                    // Set puzzle bodies
                    return {
                        bodies: [ground, leftWall, rightWall, targetZone, ball],
                        targetBody: ball,
                        targetZone: targetZone,
                        paused: false,
                        allowCreation: true
                    };
                }
            },
            {
                id: 'domino',
                title: "Domino Effect",
                difficulty: "hard",
                objective: "Knock down all dominoes with one ball",
                setup: () => {
                    // Clear existing bodies
                    Composite.clear(engine.world, false);
                    bodies.length = 0;
                    
                    // Create ground
                    const ground = Bodies.rectangle(
                        render.options.width / 2,
                        render.options.height - 20,
                        render.options.width,
                        40,
                        { isStatic: true, render: { fillStyle: '#34C759' } }
                    );
                    
                    // Create dominoes
                    const dominoes = [];
                    const dominoCount = 10;
                    const dominoWidth = 15;
                    const dominoHeight = 60;
                    const spacing = 40;
                    const startX = render.options.width / 2 - (dominoCount * spacing) / 2;
                    
                    for (let i = 0; i < dominoCount; i++) {
                        const domino = Bodies.rectangle(
                            startX + i * spacing,
                            render.options.height - 20 - dominoHeight / 2,
                            dominoWidth,
                            dominoHeight,
                            { 
                                isStatic: false, 
                                chamfer: { radius: 2 },
                                render: { fillStyle: '#5856D6' } 
                            }
                        );
                        dominoes.push(domino);
                    }
                    
                    // Create ball
                    const ball = Bodies.circle(
                        startX - 50,
                        render.options.height - 50,
                        20,
                        { 
                            isStatic: false, 
                            restitution: 0.5,
                            render: { fillStyle: '#FF3B30' } 
                        }
                    );
                    
                    Composite.add(engine.world, [ground, ...dominoes, ball]);
                    
                    // Set puzzle bodies
                    return {
                        bodies: [ground, ...dominoes, ball],
                        targetBody: dominoes[dominoes.length - 1],
                        targetZone: ground,
                        paused: false,
                        allowCreation: false
                    };
                }
            }
        ];

        // Startup Sequence
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const startupScreen = document.getElementById('startupScreen');
                const setupScreen = document.getElementById('setupScreen');
                const logoReplay = document.getElementById('logoReplay');
                const progressBar = document.getElementById('startupProgress');
                const progressText = document.getElementById('progressText');
                const dock = document.getElementById('dock');
                const startupVideo = document.getElementById('startupVideo');
                const replayVideo = document.getElementById('replayVideo');
                const continueButton = document.getElementById('continueButton');
                const skipButton = document.getElementById('skipButton');
                
                let progress = 0;
                
                // Ensure videos play
                function ensureVideoPlay(video) {
                    if (!video) return;
                    
                    const playPromise = video.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Video playback failed:", error);
                            video.style.display = 'none';
                            const fallback = video.querySelector('img');
                            if (fallback) {
                                fallback.style.display = 'block';
                                fallback.alt = 'Physical Physics Logo Fallback';
                            }
                        });
                    }
                    
                    video.addEventListener('error', () => {
                        console.error("Video error occurred");
                        video.style.display = 'none';
                        const fallback = video.querySelector('img');
                        if (fallback) fallback.style.display = 'block';
                    });
                }
                
                // Start playing videos
                ensureVideoPlay(startupVideo);
                
                function updateProgress() {
                    progress += Math.random() * 8 + 4;
                    progress = Math.min(progress, 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${translations[selectedLanguage]?.loading || 'Loading'} ${Math.floor(progress)}%`;

                    if (progress < 100) {
                        setTimeout(updateProgress, 100 + Math.random() * 150);
                    } else {
                        progressText.textContent = translations[selectedLanguage]?.ready || 'Ready!';
                        setTimeout(() => {
                            startupScreen.style.opacity = '0';
                            setTimeout(() => {
                                startupScreen.style.display = 'none';
                                
                                // Show setup screen
                                setupScreen.style.display = 'flex';
                                setTimeout(() => {
                                    setupScreen.style.opacity = '1';
                                }, 50);
                                
                            }, 800);
                        }, 1000);
                    }
                }

                // Function to update UI translations
                function updateTranslations(lang) {
                    const t = translations[lang] || translations.en;
                    
                    // Setup screen
                    document.getElementById('setupTitle').textContent = t.welcome;
                    document.getElementById('setupSubtitle').textContent = t.subtitle;
                    document.getElementById('languageTitle').textContent = t.language;
                    document.getElementById('tutorialTitle').textContent = t.tutorial;
                    document.getElementById('tutorialStep1').textContent = t.step1;
                    document.getElementById('tutorialStep2').textContent = t.step2;
                    document.getElementById('tutorialStep3').textContent = t.step3;
                    document.getElementById('tutorialStep4').textContent = t.step4;
                    document.getElementById('tutorialStep5').textContent = t.step5;
                    skipButton.textContent = t.skip;
                    continueButton.textContent = t.continue;
                    
                    // Menu title
                    document.getElementById('menuTitle').textContent = t.menuTitle;
                    
                    // Progress text
                    if (progressText) {
                        progressText.textContent = `${t.loading} ${Math.floor(progress)}%`;
                    }
                    
                    // Puzzle UI
                    document.getElementById('puzzleTitle').textContent = t.puzzleTitle;
                    document.getElementById('puzzleObjective').textContent = t.puzzleObjective;
                    document.getElementById('resetPuzzleBtn').textContent = t.resetPuzzle;
                    document.getElementById('exitPuzzleBtn').textContent = t.exitPuzzle;
                    document.getElementById('pausePuzzleBtn').textContent = t.pause;
                    document.querySelector('.puzzle-complete h2').textContent = t.puzzleComplete;
                    document.getElementById('nextPuzzleBtn').textContent = t.nextPuzzle;
                    document.querySelector('.puzzle-menu .puzzle-header').textContent = t.puzzleMenu;
                    
                    // Pause overlay
                    document.querySelector('.pause-overlay h2').textContent = t.paused;
                    document.getElementById('resumeBtn').textContent = t.resume;
                    
                    // Save/Load buttons
                    document.getElementById('saveBtn').textContent = t.save;
                    document.getElementById('loadBtn').textContent = t.load;
                    
                    // Update puzzle menu items
                    updatePuzzleMenu();
                }

                // Language selection
                document.querySelectorAll('.language-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        document.querySelectorAll('.language-option').forEach(opt => 
                            opt.classList.remove('selected'));
                        option.classList.add('selected');
                        selectedLanguage = option.dataset.lang;
                        updateTranslations(selectedLanguage);
                    });
                });
                
                function proceedToLogoReplay() {
                    setupScreen.style.opacity = '0';
                    setTimeout(() => {
                        setupScreen.style.display = 'none';
                        
                        // Show logo replay
                        logoReplay.style.display = 'flex';
                        setTimeout(() => {
                            logoReplay.style.opacity = '1';
                            
                            // Play the video once
                            replayVideo.loop = false;
                            replayVideo.currentTime = 0;
                            ensureVideoPlay(replayVideo);
                            
                            // When video ends, transition to main app
                            replayVideo.addEventListener('ended', () => {
                                logoReplay.style.opacity = '0';
                                setTimeout(() => {
                                    logoReplay.style.display = 'none';
                                    initPhysics();
                                    initDock();
                                    initTooltips();
                                    initEditControls();
                                    initPuzzleMode();
                                    initPauseSystem();
                                    initSaveLoadSystem();
                                    initTouchControls();
                                    setTimeout(() => {
                                        // Show all controls after setup is complete
                                        document.querySelector('.menu-bar').style.display = 'flex';
                                        document.querySelector('.menu-button').style.display = 'flex';
                                        document.getElementById('saveLoadControls').style.display = 'flex';
                                        
                                        // Modified dock initialization
                                        const dock = document.getElementById('dock');
                                        dock.style.display = 'flex';
                                        setTimeout(() => {
                                            dock.classList.add('visible');
                                            
                                            // Force a reflow to ensure the dock renders properly
                                            void dock.offsetWidth;
                                            
                                            // Adjust dock position if needed
                                            if (window.innerWidth > window.innerHeight) {
                                                // Landscape mode
                                                dock.style.bottom = '10px';
                                            }
                                        }, 300);
                                    }, 300);
                                }, 800);
                            }, { once: true });
                            
                            // Fallback in case video doesn't fire ended event
                            setTimeout(() => {
                                if (logoReplay.style.opacity === '1') {
                                    logoReplay.style.opacity = '0';
                                    setTimeout(() => {
                                        logoReplay.style.display = 'none';
                                        initPhysics();
                                        initDock();
                                        initTooltips();
                                        initEditControls();
                                        initPuzzleMode();
                                        initPauseSystem();
                                        initSaveLoadSystem();
                                        initTouchControls();
                                        setTimeout(() => {
                                            // Show all controls after setup is complete
                                            document.querySelector('.menu-bar').style.display = 'flex';
                                            document.querySelector('.menu-button').style.display = 'flex';
                                            document.getElementById('saveLoadControls').style.display = 'flex';
                                            
                                            // Modified dock initialization
                                            const dock = document.getElementById('dock');
                                            dock.style.display = 'flex';
                                            setTimeout(() => {
                                                dock.classList.add('visible');
                                                
                                                // Force a reflow to ensure the dock renders properly
                                                void dock.offsetWidth;
                                                
                                                // Adjust dock position if needed
                                                if (window.innerWidth > window.innerHeight) {
                                                    // Landscape mode
                                                    dock.style.bottom = '10px';
                                                }
                                            }, 300);
                                        }, 300);
                                    }, 800);
                                }
                            }, 5000); // 5 second fallback
                        }, 50);
                    }, 800);
                }

                // Skip button handler
                skipButton.addEventListener('click', proceedToLogoReplay);
                
                // Continue button handler
                continueButton.addEventListener('click', proceedToLogoReplay);
                
                // Start with English translations
                updateTranslations('en');
                
                // Start progress immediately
                updateProgress();
            } catch (error) {
                console.error("Initialization error:", error);
                document.body.innerHTML = `
                    <div style="padding: 20px; color: red;">
                        <h1>Application Error</h1>
                        <p>Sorry, the app failed to initialize. Please refresh the page.</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        });

        // Physics Engine with mobile optimizations
        function initPhysics() {
            try {
                // Create engine with better physics settings
                engine = Engine.create({
                    enableSleeping: true,
                    gravity: { x: 0, y: 1 },
                    positionIterations: isMobile() ? 6 : 8,
                    velocityIterations: isMobile() ? 4 : 6,
                    constraintIterations: 3,
                    enableSAT: true,
                    timing: {
                        timeScale: 1,
                        timestamp: 0
                    }
                });
                
                const canvas = document.getElementById('canvas');
                if (!canvas) throw new Error("Canvas element not found");
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 44;

                // Create renderer
                render = Render.create({
                    canvas: canvas,
                    engine: engine,
                    options: {
                        width: canvas.width,
                        height: canvas.height,
                        wireframes: false,
                        background: 'transparent',
                        showSleeping: false,
                        showCollisions: false,
                        showVelocity: false
                    }
                });

                // Create walls with better physics properties
                const wallOptions = { 
                    isStatic: true,
                    friction: 0.3,
                    frictionStatic: 0.5,
                    restitution: 0.2,
                    render: { 
                        fillStyle: '#8E8E93',
                        visible: true
                    } 
                };

                const walls = [
                    Bodies.rectangle(
                        canvas.width/2, 
                        canvas.height + 20,
                        canvas.width * 1.5,
                        80,
                        wallOptions
                    ),
                    Bodies.rectangle(
                        -30,
                        canvas.height/2, 
                        60,
                        canvas.height * 1.2,
                        wallOptions
                    ),
                    Bodies.rectangle(
                        canvas.width + 30,
                        canvas.height/2, 
                        60,
                        canvas.height * 1.2,
                        wallOptions
                    )
                ];

                Composite.add(engine.world, walls);
                Render.run(render);
                
                // Create runner with fixed timestep
                runner = Runner.create({
                    delta: 1000 / 60,  // 60 FPS
                    isFixed: true
                });
                Runner.run(runner, engine);

                // Collision sound & particles
                Matter.Events.on(engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        // Play sound for significant collisions
                        if (pair.bodyA.speed > 0.5 || pair.bodyB.speed > 0.5) {
                            audio.play('thud', 0.1 + Math.min(0.4, pair.collision.depth * 0.05));
                        }

                        // Spawn particles at collision point
                        const avgX = (pair.bodyA.position.x + pair.bodyB.position.x) / 2;
                        const avgY = (pair.bodyA.position.y + pair.bodyB.position.y) / 2;
                        spawnParticles(avgX, avgY, '#FFD700', 5);
                    });
                });

                // Click Handling - Modified to create only one object
                const clickHandler = (e) => {
                    if (isProcessingClick || (editMode && !moveMode)) return;
                    isProcessingClick = true;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (currentMode === 'delete') {
                        const found = Query.point(bodies, {x, y});
                        if (found.length) {
                            removeBody(found[0]);
                        }
                    } else if (!puzzleMode || (currentPuzzle && currentPuzzle.allowCreation)) {
                        // Create only one object at the click position
                        const body = createBody(x, y);
                        if (body) {
                            audio.play('click');
                            spawnParticles(x, y, body.render.fillStyle, 3);
                        }
                    }
                    
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 100);
                };
                canvas.addEventListener('click', clickHandler);

                // Double click to enter edit mode (desktop)
                if (!isMobile()) {
                    const dblClickHandler = (e) => {
                        if (editMode || puzzleMode) return;
                        
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const found = Query.point(bodies, {x, y});
                        if (found.length) {
                            enterEditMode(found[0]);
                        }
                    };
                    canvas.addEventListener('dblclick', dblClickHandler);
                }
            } catch (error) {
                console.error("Physics initialization error:", error);
                showNotification("Failed to initialize physics engine", true);
            }
        }

        function removeBody(body) {
            try {
                Composite.remove(engine.world, body);
                const index = bodies.indexOf(body);
                if (index > -1) {
                    bodies.splice(index, 1);
                }
                // Nullify references
                if (selectedBody === body) selectedBody = null;
            } catch (error) {
                console.error("Error removing body:", error);
            }
        }

        function enterEditMode(body) {
            try {
                editMode = true;
                selectedBody = body;
                originalBodyState = {
                    position: { x: body.position.x, y: body.position.y },
                    size: body.bounds.max.x - body.bounds.min.x,
                    mass: body.mass,
                    restitution: body.restitution,
                    friction: body.friction,
                    isStatic: body.isStatic
                };

                // Set slider value
                document.getElementById('sizeSlider').value = originalBodyState.size;
                
                // Show edit controls
                const editControls = document.getElementById('editControls');
                editControls.style.display = 'flex';
                
                // Position controls for mobile
                if (isMobile()) {
                    editControls.style.bottom = '80px';
                    editControls.style.width = '90%';
                }
                
                // Make body static while editing
                Body.setStatic(body, true);
                
                // Add touch move handler for mobile
                if (isMobile()) {
                    const moveHandler = (e) => {
                        if (!editMode || !selectedBody) return;
                        
                        const touch = e.touches[0];
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        Body.setPosition(selectedBody, { x, y });
                        e.preventDefault();
                    };
                    
                    canvas.addEventListener('touchmove', moveHandler, { passive: false });
                    selectedBody._moveHandler = moveHandler;
                }
            } catch (error) {
                console.error("Error entering edit mode:", error);
            }
        }

        function exitEditMode(saveChanges) {
            if (!editMode) return;
            
            try {
                if (saveChanges && selectedBody) {
                    // Apply changes
                    const newSize = parseInt(document.getElementById('sizeSlider').value);
                    resizeBody(selectedBody, newSize);
                } else if (selectedBody) {
                    // Revert changes
                    Body.setPosition(selectedBody, originalBodyState.position);
                    if (originalBodyState.size !== (selectedBody.bounds.max.x - selectedBody.bounds.min.x)) {
                        resizeBody(selectedBody, originalBodyState.size);
                    }
                    Body.setMass(selectedBody, originalBodyState.mass);
                    Body.set(selectedBody, {
                        restitution: originalBodyState.restitution,
                        friction: originalBodyState.friction,
                        frictionStatic: originalBodyState.friction,
                        isStatic: originalBodyState.isStatic
                    });
                }
                
                // Restore body physics
                if (selectedBody) {
                    Body.setStatic(selectedBody, false);
                    
                    // Remove touch move handler if it exists
                    if (selectedBody._moveHandler) {
                        canvas.removeEventListener('touchmove', selectedBody._moveHandler);
                        delete selectedBody._moveHandler;
                    }
                }
                
                // Reset edit mode
                editMode = false;
                moveMode = false;
                resizeMode = false;
                selectedBody = null;
                originalBodyState = null;
                
                // Hide edit controls
                document.getElementById('editControls').style.display = 'none';
            } catch (error) {
                console.error("Error exiting edit mode:", error);
            }
        }

        function resizeBody(body, newSize) {
            try {
                const scale = newSize / (body.bounds.max.x - body.bounds.min.x);
                Body.scale(body, scale, scale);
            } catch (error) {
                console.error("Error resizing body:", error);
            }
        }

        function createBody(x, y, type = currentMode) {
            try {
                const size = 30 + Math.random() * 20;
                let body;
                let objectName = '';

                // Enhanced physics properties for more realistic behavior
                const commonProps = {
                    friction: 0.3,
                    frictionStatic: 0.5,
                    frictionAir: 0.01,
                    restitution: 0.4,
                    density: 0.001,
                    slop: 0.5,
                    collisionFilter: {
                        group: 0,
                        category: 0x0001,
                        mask: 0xFFFFFFFF
                    },
                    sleepThreshold: 60, // Higher threshold to prevent premature sleeping
                    timeScale: 1
                };

                switch(type) {
                    case 'box':
                        body = Bodies.rectangle(x, y, size, size, {
                            ...commonProps,
                            chamfer: { radius: 2 },
                            render: { fillStyle: '#007AFF' }
                        });
                        objectName = translations[selectedLanguage]?.box || 'Box';
                        break;
                    case 'circle':
                        body = Bodies.circle(x, y, size/2, {
                            ...commonProps,
                            render: { fillStyle: '#FF3B30' }
                        });
                        objectName = translations[selectedLanguage]?.circle || 'Circle';
                        break;
                    case 'triangle':
                        const triangleVertices = [
                            { x: 0, y: -size/2 },
                            { x: size/2, y: size/2 },
                            { x: -size/2, y: size/2 }
                        ];
                        body = Bodies.fromVertices(x, y, [triangleVertices], {
                            ...commonProps,
                            render: { fillStyle: '#FFD700' }
                        });
                        objectName = translations[selectedLanguage]?.triangle || 'Triangle';
                        break;
                    case 'hexagon':
                        const hexagonVertices = [];
                        const sides = 6;
                        const radius = size/1.5;
                        for (let i = 0; i < sides; i++) {
                            const angle = (Math.PI * 2 * i) / sides - Math.PI/6;
                            hexagonVertices.push({
                                x: radius * Math.cos(angle),
                                y: radius * Math.sin(angle)
                            });
                        }
                        body = Bodies.fromVertices(x, y, [hexagonVertices], {
                            ...commonProps,
                            render: { 
                                fillStyle: '#FF69B4',
                                strokeStyle: '#FF1493',
                                lineWidth: 2
                            }
                        });
                        objectName = translations[selectedLanguage]?.hexagon || 'Hexagon';
                        break;
                    case 'static':
                        body = Bodies.rectangle(x, y, size, size, {
                            isStatic: true,
                            friction: 0.5,
                            frictionStatic: 0.8,
                            render: { fillStyle: '#34C759' }
                        });
                        objectName = translations[selectedLanguage]?.static || 'Static Block';
                        break;
                }

                if (body) {
                    body.tooltipName = objectName;
                    Composite.add(engine.world, body);
                    bodies.push(body);
                    
                    // Wake up all bodies when a new one is added to prevent stacking issues
                    bodies.forEach(b => {
                        if (!b.isStatic) {
                            Body.setSleeping(b, false);
                        }
                    });
                    
                    return body;
                }
                return null;
            } catch (error) {
                console.error("Error creating body:", error);
                return null;
            }
        }

        // Dock System with mobile optimizations
        function initDock() {
            try {
                const dock = document.getElementById('dock');
                if (!dock) return;
                
                let isDragging = false;
                let startX, startY, startLeft, startTop;

                // Load saved position
                const savedPos = localStorage.getItem('dockPos');
                if (savedPos) {
                    const pos = JSON.parse(savedPos);
                    dock.style.left = `${pos.x}px`;
                    dock.style.bottom = `${pos.y}px`;
                    dock.style.transform = 'none';
                }

                const mouseDownHandler = (e) => {
                    if (e.target.classList.contains('dock-item')) return;
                    
                    isDragging = true;
                    const rect = dock.getBoundingClientRect();
                    startX = e.clientX || e.touches[0].clientX;
                    startY = e.clientY || e.touches[0].clientY;
                    startLeft = rect.left;
                    startTop = rect.top;
                    
                    dock.style.cursor = 'grabbing';
                    e.preventDefault();
                };

                const mouseMoveHandler = (e) => {
                    if (!isDragging) return;

                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    if (!clientX || !clientY) return;

                    const dx = clientX - startX;
                    const dy = clientY - startY;

                    let newLeft = startLeft + dx;
                    let newTop = startTop + dy;

                    // Boundary constraints
                    const maxX = window.innerWidth - dock.offsetWidth;
                    const maxY = window.innerHeight - dock.offsetHeight;

                    newLeft = Math.max(0, Math.min(newLeft, maxX));
                    newTop = Math.max(0, Math.min(newTop, maxY));

                    dock.style.left = `${newLeft}px`;
                    dock.style.top = `${newTop}px`;
                    dock.style.bottom = 'auto';
                    dock.style.transform = 'none';
                    
                    e.preventDefault();
                };

                const mouseUpHandler = () => {
                    if (isDragging) {
                        isDragging = false;
                        dock.style.cursor = 'grab';
                        
                        const rect = dock.getBoundingClientRect();
                        localStorage.setItem('dockPos', JSON.stringify({
                            x: rect.left,
                            y: window.innerHeight - rect.bottom
                        }));
                    }
                };

                // Touch events
                dock.addEventListener('touchstart', mouseDownHandler, { passive: false });
                document.addEventListener('touchmove', mouseMoveHandler, { passive: false });
                document.addEventListener('touchend', mouseUpHandler, { passive: false });
                
                // Mouse events
                dock.addEventListener('mousedown', mouseDownHandler);
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);

                // Mode Selection
                document.querySelectorAll('.dock-item').forEach(item => {
                    item.addEventListener('click', () => {
                        if (editMode) return;
                        
                        // Handle pause mode separately
                        if (item.dataset.mode === 'pause') {
                            togglePause();
                            return;
                        }
                        
                        document.querySelectorAll('.dock-item').forEach(i => 
                            i.classList.remove('active'));
                        item.classList.add('active');
                        currentMode = item.dataset.mode;
                    });
                });
            } catch (error) {
                console.error("Dock initialization error:", error);
            }
        }

        // Tooltip System
        function initTooltips() {
            try {
                const tooltip = document.getElementById('tooltip');
                const canvas = document.getElementById('canvas');
                if (!tooltip || !canvas) return;

                function updateTooltip(e) {
                    if (!engine || editMode) return;
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    if (!clientX || !clientY) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = clientX - rect.left;
                    const mouseY = clientY - rect.top;
                    
                    // Find body under mouse
                    const body = Query.point(bodies, {x: mouseX, y: mouseY})[0];
                    
                    if (body && body.tooltipName) {
                        // Position tooltip above the mouse
                        tooltip.textContent = body.tooltipName;
                        tooltip.style.left = `${clientX}px`;
                        tooltip.style.top = `${clientY - 30}px`;
                        tooltip.classList.add('visible');
                    } else {
                        tooltip.classList.remove('visible');
                    }
                }

                canvas.addEventListener('mousemove', updateTooltip);
                canvas.addEventListener('touchmove', updateTooltip, { passive: false });
                canvas.addEventListener('mouseout', () => {
                    tooltip.classList.remove('visible');
                });
                canvas.addEventListener('touchend', () => {
                    tooltip.classList.remove('visible');
                });
            } catch (error) {
                console.error("Tooltip initialization error:", error);
            }
        }

        // Initialize edit controls
        function initEditControls() {
            try {
                const moveBtn = document.getElementById('moveBtn');
                const resizeBtn = document.getElementById('resizeBtn');
                const confirmBtn = document.getElementById('confirmEditBtn');
                const cancelBtn = document.getElementById('cancelEditBtn');
                const sizeSlider = document.getElementById('sizeSlider');
                const canvas = document.getElementById('canvas');
                if (!moveBtn || !resizeBtn || !confirmBtn || !cancelBtn || !sizeSlider || !canvas) return;

                moveBtn.addEventListener('click', () => {
                    moveMode = !moveMode;
                    resizeMode = false;
                    moveBtn.classList.toggle('active', moveMode);
                    resizeBtn.classList.remove('active');
                });

                resizeBtn.addEventListener('click', () => {
                    resizeMode = !resizeMode;
                    moveMode = false;
                    resizeBtn.classList.toggle('active', resizeMode);
                    moveBtn.classList.remove('active');
                });

                confirmBtn.addEventListener('click', () => {
                    exitEditMode(true);
                });

                cancelBtn.addEventListener('click', () => {
                    exitEditMode(false);
                });

                // Handle moving the object (desktop)
                const moveHandler = (e) => {
                    if (!editMode || !moveMode || !selectedBody) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    Body.setPosition(selectedBody, { x, y });
                };
                canvas.addEventListener('mousemove', moveHandler);

                // Update size in real-time
                sizeSlider.addEventListener('input', () => {
                    if (!editMode || !resizeMode || !selectedBody) return;
                    resizeBody(selectedBody, parseInt(sizeSlider.value));
                });
            } catch (error) {
                console.error("Edit controls initialization error:", error);
            }
        }

        // Initialize Save/Load System
        function initSaveLoadSystem() {
            try {
                const saveBtn = document.getElementById('saveBtn');
                const loadBtn = document.getElementById('loadBtn');
                
                if (!saveBtn || !loadBtn) return;

                saveBtn.addEventListener('click', saveScene);
                loadBtn.addEventListener('click', loadScene);
            } catch (error) {
                console.error("Save/Load system initialization error:", error);
            }
        }

        function saveScene() {
            try {
                const sceneData = {
                    bodies: bodies.map(body => ({
                        type: body.tooltipName.toLowerCase().replace(' ', '_'),
                        position: { x: body.position.x, y: body.position.y },
                        size: body.bounds.max.x - body.bounds.min.x,
                        options: {
                            render: { fillStyle: body.render.fillStyle },
                            isStatic: body.isStatic,
                            mass: body.mass,
                            restitution: body.restitution,
                            friction: body.friction
                        }
                    })),
                    puzzleMode: puzzleMode,
                    currentPuzzle: puzzleMode ? currentPuzzle.id : null
                };
                localStorage.setItem('physicalPhysicsScene', JSON.stringify(sceneData));
                showNotification(translations[selectedLanguage]?.sceneSaved || 'Scene saved successfully!');
            } catch (error) {
                console.error("Error saving scene:", error);
                showNotification(translations[selectedLanguage]?.loadError || 'Error saving scene', true);
            }
        }

        function loadScene() {
            try {
                const savedData = localStorage.getItem('physicalPhysicsScene');
                if (!savedData) {
                    showNotification("No saved scene found", true);
                    return;
                }
                
                const sceneData = JSON.parse(savedData);
                
                // Clear current scene
                Composite.clear(engine.world, false);
                bodies.length = 0;
                
                // Recreate bodies
                sceneData.bodies.forEach(savedBody => {
                    const body = createBody(
                        savedBody.position.x, 
                        savedBody.position.y, 
                        savedBody.type.replace('_', ' ')
                    );
                    if (body) {
                        if (savedBody.size) {
                            resizeBody(body, savedBody.size);
                        }
                        if (savedBody.options) {
                            Body.set(body, {
                                isStatic: savedBody.options.isStatic,
                                mass: savedBody.options.mass,
                                restitution: savedBody.options.restitution,
                                friction: savedBody.options.friction,
                                frictionStatic: savedBody.options.friction
                            });
                            if (body.render) {
                                body.render.fillStyle = savedBody.options.render.fillStyle;
                            }
                        }
                    }
                });
                
                // Restore puzzle mode if applicable
                if (sceneData.puzzleMode && sceneData.currentPuzzle) {
                    const puzzle = puzzles.find(p => p.id === sceneData.currentPuzzle);
                    if (puzzle) startPuzzle(puzzle);
                }
                
                showNotification(translations[selectedLanguage]?.sceneLoaded || 'Scene loaded successfully!');
            } catch (error) {
                console.error("Error loading scene:", error);
                showNotification(translations[selectedLanguage]?.loadError || 'Error loading scene', true);
            }
        }

        function showNotification(message, isError = false) {
            try {
                const notification = document.createElement('div');
                notification.className = `notification ${isError ? 'error' : 'success'}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.classList.add('fade-out');
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            } catch (error) {
                console.error("Error showing notification:", error);
            }
        }

        // Initialize Puzzle Mode
        function initPuzzleMode() {
            try {
                const menuButton = document.getElementById('menuButton');
                const puzzleMenu = document.getElementById('puzzleMenu');
                const puzzleModeUI = document.getElementById('puzzleMode');
                const resetPuzzleBtn = document.getElementById('resetPuzzleBtn');
                const exitPuzzleBtn = document.getElementById('exitPuzzleBtn');
                const pausePuzzleBtn = document.getElementById('pausePuzzleBtn');
                const puzzleComplete = document.getElementById('puzzleComplete');
                const nextPuzzleBtn = document.getElementById('nextPuzzleBtn');
                
                if (!menuButton || !puzzleMenu || !puzzleModeUI || !resetPuzzleBtn || 
                    !exitPuzzleBtn || !pausePuzzleBtn || !puzzleComplete || !nextPuzzleBtn) {
                    throw new Error("Puzzle mode elements not found");
                }
                
                // Update puzzle menu with available puzzles
                updatePuzzleMenu();
                
                // Toggle puzzle menu
                menuButton.addEventListener('click', () => {
                    puzzleMenu.style.display = puzzleMenu.style.display === 'flex' ? 'none' : 'flex';
                });
                
                // Reset puzzle button
                resetPuzzleBtn.addEventListener('click', resetPuzzle);
                
                // Exit puzzle button
                exitPuzzleBtn.addEventListener('click', exitPuzzleMode);
                
                // Pause puzzle button
                pausePuzzleBtn.addEventListener('click', togglePause);
                
                // Next puzzle button
                nextPuzzleBtn.addEventListener('click', () => {
                    puzzleComplete.style.display = 'none';
                    const nextPuzzleIndex = puzzles.findIndex(p => p.id === currentPuzzle.id) + 1;
                    if (nextPuzzleIndex < puzzles.length) {
                        startPuzzle(puzzles[nextPuzzleIndex]);
                    } else {
                        exitPuzzleMode();
                    }
                });
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!puzzleMenu.contains(e.target) && e.target !== menuButton) {
                        puzzleMenu.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("Puzzle mode initialization error:", error);
            }
        }
        
        function updatePuzzleMenu() {
            try {
                const puzzleMenu = document.getElementById('puzzleMenu');
                if (!puzzleMenu) return;
                
                // Clear existing items except header
                while (puzzleMenu.children.length > 1) {
                    puzzleMenu.removeChild(puzzleMenu.lastChild);
                }
                
                // Add puzzle items
                puzzles.forEach(puzzle => {
                    const item = document.createElement('div');
                    item.className = 'puzzle-menu-item';
                    if (currentPuzzle && puzzle.id === currentPuzzle.id) {
                        item.classList.add('active');
                    }
                    item.innerHTML = `
                        ${puzzle.title}
                        <div class="puzzle-difficulty">${translations[selectedLanguage]?.[puzzle.difficulty] || puzzle.difficulty}</div>
                    `;
                    item.addEventListener('click', () => {
                        startPuzzle(puzzle);
                        puzzleMenu.style.display = 'none';
                    });
                    puzzleMenu.appendChild(item);
                });
            } catch (error) {
                console.error("Error updating puzzle menu:", error);
            }
        }
        
        function startPuzzle(puzzle) {
            try {
                // Clear any existing puzzle
                if (puzzleMode) {
                    resetPuzzle();
                }
                
                // Set puzzle mode
                puzzleMode = true;
                currentPuzzle = puzzle;
                
                // Hide dock and edit controls
                document.getElementById('dock').classList.remove('visible');
                document.getElementById('editControls').style.display = 'none';
                document.getElementById('saveLoadControls').style.display = 'none';
                
                // Setup puzzle
                const puzzleSetup = puzzle.setup();
                puzzleBodies = puzzleSetup.bodies;
                targetBody = puzzleSetup.targetBody;
                targetZone = puzzleSetup.targetZone;
                
                // Update UI
                document.getElementById('puzzleTitle').textContent = puzzle.title;
                document.getElementById('puzzleObjective').textContent = puzzle.objective;
                document.getElementById('puzzleMode').style.display = 'flex';
                
                // Mobile adjustments
                if (isMobile()) {
                    document.getElementById('puzzleMode').style.left = '10px';
                    document.getElementById('puzzleMode').style.right = '10px';
                    document.getElementById('puzzleMode').style.width = 'calc(100% - 20px)';
                }
                
                // Start in paused state
                if (puzzleSetup.paused) {
                    togglePause(true);
                }
                
                // Start checking for puzzle completion
                puzzleCheckInterval = setInterval(checkPuzzleComplete, 100);
            } catch (error) {
                console.error("Error starting puzzle:", error);
                showNotification("Failed to start puzzle", true);
            }
        }
        
        function createTargetZone(x, y, width, height) {
            try {
                // Remove existing target zone visual if any
                const existingZone = document.querySelector('.target-zone');
                if (existingZone) {
                    existingZone.remove();
                }
                
                // Create new target zone visual
                const zone = document.createElement('div');
                zone.className = 'target-zone';
                zone.style.left = `${x}px`;
                zone.style.top = `${y}px`;
                zone.style.width = `${width}px`;
                zone.style.height = `${height}px`;
                document.body.appendChild(zone);
            } catch (error) {
                console.error("Error creating target zone:", error);
            }
        }
        
        function checkPuzzleComplete() {
            try {
                if (!puzzleMode || !targetBody || !targetZone || isPaused) return;
                
                // Check if target body is overlapping with target zone
                const collisions = Matter.Query.collides(targetBody, [targetZone]);
                
                if (collisions.length > 0) {
                    // Puzzle complete!
                    clearInterval(puzzleCheckInterval);
                    puzzleComplete();
                }
            } catch (error) {
                console.error("Error checking puzzle completion:", error);
                clearInterval(puzzleCheckInterval);
            }
        }
        
        function puzzleComplete() {
            try {
                const puzzleComplete = document.getElementById('puzzleComplete');
                const completeMessage = document.getElementById('completeMessage');
                
                completeMessage.textContent = `You completed "${currentPuzzle.title}"!`;
                puzzleComplete.style.display = 'flex';
                
                // Play success sound and particles
                audio.play('success');
                spawnParticles(
                    targetZone.position.x, 
                    targetZone.position.y, 
                    '#00FF00', 
                    20
                );
                
                // Check if there's a next puzzle
                const nextPuzzleIndex = puzzles.findIndex(p => p.id === currentPuzzle.id) + 1;
                if (nextPuzzleIndex >= puzzles.length) {
                    document.getElementById('nextPuzzleBtn').style.display = 'none';
                } else {
                    document.getElementById('nextPuzzleBtn').style.display = 'block';
                }
            } catch (error) {
                console.error("Error showing puzzle complete:", error);
            }
        }
        
        function resetPuzzle() {
            try {
                if (!puzzleMode) return;
                
                // Clear existing puzzle bodies
                Composite.remove(engine.world, puzzleBodies);
                
                // Reset puzzle
                const puzzleSetup = currentPuzzle.setup();
                puzzleBodies = puzzleSetup.bodies;
                targetBody = puzzleSetup.targetBody;
                targetZone = puzzleSetup.targetZone;
                
                // Reset pause state if needed
                if (puzzleSetup.paused && !isPaused) {
                    togglePause(true);
                } else if (!puzzleSetup.paused && isPaused) {
                    togglePause(false);
                }
            } catch (error) {
                console.error("Error resetting puzzle:", error);
                showNotification("Failed to reset puzzle", true);
            }
        }
        
        function exitPuzzleMode() {
            try {
                if (!puzzleMode) return;
                
                // Clear puzzle
                clearInterval(puzzleCheckInterval);
                Composite.remove(engine.world, puzzleBodies);
                
                // Remove target zone visual
                const existingZone = document.querySelector('.target-zone');
                if (existingZone) {
                    existingZone.remove();
                }
                
                // Hide puzzle UI
                document.getElementById('puzzleMode').style.display = 'none';
                document.getElementById('puzzleComplete').style.display = 'none';
                
                // Reset variables
                puzzleMode = false;
                currentPuzzle = null;
                targetBody = null;
                targetZone = null;
                puzzleBodies = [];
                
                // Show dock and save/load controls
                document.getElementById('dock').classList.add('visible');
                document.getElementById('saveLoadControls').style.display = 'flex';
                
                // Update puzzle menu
                updatePuzzleMenu();
                
                // Ensure we're not paused
                if (isPaused) {
                    togglePause(false);
                }
            } catch (error) {
                console.error("Error exiting puzzle mode:", error);
            }
        }

        // Initialize pause system
        function initPauseSystem() {
            try {
                const pauseOverlay = document.getElementById('pauseOverlay');
                const resumeBtn = document.getElementById('resumeBtn');
                
                if (!pauseOverlay || !resumeBtn) return;

                resumeBtn.addEventListener('click', () => {
                    togglePause(false);
                });
            } catch (error) {
                console.error("Pause system initialization error:", error);
            }
        }

        function togglePause(forceState = null) {
            try {
                const pauseOverlay = document.getElementById('pauseOverlay');
                const pausePuzzleBtn = document.getElementById('pausePuzzleBtn');
                const t = translations[selectedLanguage] || translations.en;
                
                // Determine new state
                const newState = forceState !== null ? forceState : !isPaused;
                
                if (newState) {
                    // Pause the simulation
                    prePauseRunner = runner;
                    Runner.stop(runner);
                    runner = null;
                    isPaused = true;
                    
                    // Show pause overlay
                    pauseOverlay.style.display = 'flex';
                    
                    // Update button text
                    if (pausePuzzleBtn) {
                        pausePuzzleBtn.textContent = t.resume;
                    }
                    
                    // Allow editing while paused
                    document.getElementById('editControls').style.display = 'flex';
                } else {
                    // Resume the simulation
                    if (prePauseRunner) {
                        runner = Runner.create({
                            delta: 1000 / 60,
                            isFixed: true
                        });
                        Runner.run(runner, engine);
                        prePauseRunner = null;
                    }
                    isPaused = false;
                    
                    // Hide pause overlay
                    pauseOverlay.style.display = 'none';
                    
                    // Update button text
                    if (pausePuzzleBtn) {
                        pausePuzzleBtn.textContent = t.pause;
                    }
                    
                    // Hide edit controls if not in edit mode
                    if (!editMode) {
                        document.getElementById('editControls').style.display = 'none';
                    }
                }
            } catch (error) {
                console.error("Error toggling pause:", error);
            }
        }

        // Initialize Touch Controls
        function initTouchControls() {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) return;
                
                let touchStartPos = null;
                let touchStartTime = 0;
                let initialDistance = 0;
                let initialSize = 0;
                let longPressTimer = null;
                const LONG_PRESS_DURATION = 500; // ms

                // Single touch handlers
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        touchStartPos = { x: touch.clientX, y: touch.clientY };
                        touchStartTime = Date.now();
                        
                        // Long press for edit mode
                        longPressTimer = setTimeout(() => {
                            if (!touchStartPos) return;
                            const rect = canvas.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const y = touch.clientY - rect.top;
                            const found = Query.point(bodies, {x, y});
                            if (found.length) enterEditMode(found[0]);
                        }, LONG_PRESS_DURATION);
                    }
                    e.preventDefault();
                }, { passive: false });

                canvas.addEventListener('touchend', (e) => {
                    clearTimeout(longPressTimer);
                    
                    if (!touchStartPos || e.changedTouches.length !== 1) return;
                    const touch = e.changedTouches[0];
                    const endPos = { x: touch.clientX, y: touch.clientY };
                    const duration = Date.now() - touchStartTime;
                    
                    // Handle tap
                    if (duration < 300 && 
                        Math.hypot(endPos.x - touchStartPos.x, endPos.y - touchStartPos.y) < 10) {
                        handleTap(touch);
                    }
                    
                    touchStartPos = null;
                    initialDistance = 0;
                    e.preventDefault();
                }, { passive: false });

                // Pinch zoom for resizing in edit mode
                canvas.addEventListener('touchmove', (e) => {
                    if (editMode && selectedBody && e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (initialDistance === 0) {
                            initialDistance = currentDistance;
                            initialSize = selectedBody.bounds.max.x - selectedBody.bounds.min.x;
                        } else {
                            const scale = currentDistance / initialDistance;
                            resizeBody(selectedBody, initialSize * scale);
                            document.getElementById('sizeSlider').value = initialSize * scale;
                        }
                        
                        e.preventDefault();
                    }
                }, { passive: false });

                function handleTap(touch) {
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    if (currentMode === 'delete') {
                        const found = Query.point(bodies, {x, y});
                        if (found.length) removeBody(found[0]);
                    } else if (!puzzleMode || (currentPuzzle?.allowCreation)) {
                        // Create only one object at the touch position
                        const body = createBody(x, y);
                        if (body) {
                            audio.play('click');
                            spawnParticles(x, y, body.render.fillStyle, 3);
                        }
                    }
                }
            } catch (error) {
                console.error("Touch controls initialization error:", error);
            }
        }

        // Window Resize Handler
        window.addEventListener('resize', () => {
            try {
                if (!render) return;

                const canvas = document.getElementById('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 44;

                render.options.width = canvas.width;
                render.options.height = canvas.height;
                render.bounds.max.x = canvas.width;
                render.bounds.max.y = canvas.height;

                const walls = Composite.allBodies(engine.world)
                    .filter(b => b.isStatic);

                if (walls.length >= 3) {
                    Body.setPosition(walls[0], {
                        x: canvas.width/2,
                        y: canvas.height + 20
                    });

                    Body.setPosition(walls[1], {
                        x: -30,
                        y: canvas.height/2
                    });

                    Body.setPosition(walls[2], {
                        x: canvas.width + 30,
                        y: canvas.height/2
                    });
                }
                
                // Adjust dock position based on orientation
                const dock = document.getElementById('dock');
                if (dock) {
                    if (window.innerWidth > window.innerHeight) {
                        // Landscape mode
                        dock.style.bottom = '10px';
                    } else {
                        // Portrait mode
                        dock.style.bottom = '20px';
                    }
                }
                
                // Redraw target zone if in puzzle mode
                if (puzzleMode && targetZone) {
                    createTargetZone(
                        targetZone.bounds.min.x, 
                        targetZone.bounds.min.y, 
                        targetZone.bounds.max.x - targetZone.bounds.min.x, 
                        targetZone.bounds.max.y - targetZone.bounds.min.y
                    );
                }
            } catch (error) {
                console.error("Error handling window resize:", error);
            }
        });
    </script>
</body>
</html>
